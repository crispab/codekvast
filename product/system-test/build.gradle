// --- End-to-end system test -----------------------------------------------------------------------------------

import groovy.sql.Sql

import java.sql.Driver
import java.sql.DriverManager
import java.sql.SQLNonTransientConnectionException

apply plugin: 'groovy'
apply from: "$rootDir/gradle/java.gradle"
apply plugin: 'io.spring.dependency-management'

dependencyManagement {
    imports {
        mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
    }
}

configurations {
    jdbc
}

ext.systemTestJdbcPort = allocateFreePort()
ext.systemTestAppPort = allocateFreePort()
ext.systemTestManagementPort = allocateFreePort()
ext.systemTestEndpointFile = file("build/systemTestEndpoint.txt")

dependencies {
    testCompileOnly lombok

    testCompile project(':product:common')
    testCompile project(':product:testsupport')
    testCompile 'org.gebish:geb-spock:2.2'
    testCompile 'org.spockframework:spock-core:1.1-groovy-2.4'
    testCompile "org.seleniumhq.selenium:selenium-api:$seleniumVersion"

    testRuntime "org.seleniumhq.selenium:selenium-remote-driver:$seleniumVersion"
    testRuntime "org.seleniumhq.selenium:selenium-chrome-driver:$seleniumVersion"
    testRuntime "org.seleniumhq.selenium:selenium-firefox-driver:$seleniumVersion"
    testRuntime "org.seleniumhq.selenium:selenium-support:$seleniumVersion"

    jdbc mariadbDriver
}

private String startSystemTestEnvironment() {

    logger.lifecycle("Stopping previous system test environments (if any)...")
    doStopSystemTestEnvironment(true)

    def command = 'docker pull mariadb:10'
    logger.lifecycle(command)
    assert command.execute().waitFor() == 0

    command = 'docker run -d --restart=unless-stopped ' +
        "--name codekvast_systest_$systemTestJdbcPort " +
        "-p $systemTestJdbcPort:3306 " +
        '-e MYSQL_ROOT_PASSWORD=root ' +
        '-e MYSQL_DATABASE=codekvast ' +
        '-e MYSQL_USER=codekvast ' +
        '-e MYSQL_PASSWORD=codekvast ' +
        '-e TERM=xterm-256color ' +
        'mariadb:10 ' +
        '--character-set-server=utf8 ' +
        '--collation-server=utf8_general_ci ' +
        '--default-storage-engine=innodb '
    logger.lifecycle(command)
    assert command.execute().waitFor() == 0

    def jdbcUrl = "jdbc:mariadb://localhost:$systemTestJdbcPort/codekvast"
    logger.info("jdbcUrl={}", jdbcUrl)

    waitForDatabaseReady(jdbcUrl)

    command = "java " +
        "-jar ${tasks.getByPath(':product:dashboard:bootJar').outputs.files.asPath} " +
        "--server.port=$systemTestAppPort " +
        "--management.server.port=$systemTestManagementPort " +
        "--spring.datasource.url=$jdbcUrl " +
        "--codekvast.dashboardJwtSecret=secret " +
        "--logging.file=${buildDir}/log/systemTest.log "

    launchAppAndWaitForReady(command)
    systemTestEndpointFile.text = getSystemTestEndpoint()
    return systemTestEndpointFile.text
}

int allocateFreePort() {
    ServerSocket socket = null
    try {
        socket = new ServerSocket(0)
        return socket.getLocalPort()
    } finally {
        socket.close()
    }
}

def waitForDatabaseReady(jdbcUrl) {
    URLClassLoader loader = GroovyObject.class.classLoader
    configurations.jdbc.each { File file ->
        loader.addURL(file.toURI().toURL())
    }
    Class driver = loader.loadClass('org.mariadb.jdbc.Driver')
    Driver instance = driver.newInstance()
    DriverManager.registerDriver(instance)

    logger.lifecycle("Waiting for {} to become ready...", jdbcUrl)
    int attempt = 1
    while (attempt <= 60) {
        try {
            logger.info("Waiting for {} #{}", jdbcUrl, attempt)
            def sql = Sql.newInstance(jdbcUrl, 'codekvast', 'codekvast')

            sql.eachRow('SHOW TABLES') { row ->
                logger.debug("row={}", row[0])
            }
            return
        } catch (SQLNonTransientConnectionException e) {
            logger.debug("Exception=" + e)

            attempt += 1
            sleep(1000)
        }
    }
}

task stopSystemTestEnvironment {
    description 'Stop system test environment'
    group 'System test'

    doLast {
        doStopSystemTestEnvironment(true)
    }
}

private doStopSystemTestEnvironment(boolean deleteEndpointsFile) {
    file("src/test/bin/stop-system-test-environment.sh").absolutePath.execute()
    if (deleteEndpointsFile) {
        delete systemTestEndpointFile
    }
}

task psSystemTestEnvironment {
    description 'Shows the system test environment'
    group 'System test'
    doLast {
        def endpoint = getSystemTestEndpoint()

        logger.lifecycle("{}", endpoint)
        if (endpoint.isEmpty()) {
            // Remove any dangling MariaDB containers too...
            doStopSystemTestEnvironment(true)
        } else {
            systemTestEndpointFile.text = endpoint
        }
    }
}

test {
    description 'Runs end-to-end tests against Codekvast Dashboard with MariaDB in a Docker container'
    dependsOn ':product:dashboard:bootJar', ':tools:downloadChromeDriver', ':tools:downloadGeckoDriver'

    def foundChromeBinary = locateChromeBinary()
    assert !foundChromeBinary.isEmpty() : "Cannot find Chrome executable!"

    ext.gebEnv = project.findProperty("browser") ?: "chromeHeadless"

    inputs.files tasks.getByPath(":product:dashboard:bootJar").outputs.files
    inputs.property "geb.env", gebEnv

    def failures = 0

    afterTest { descriptor, result ->
        logger.debug("test={}, result={}", descriptor, result)
        failures += result.failedTestCount
    }

    doFirst {
        def chromeDriver = tasks.getByPath(':tools:downloadChromeDriver').outputs.files.asPath
        def geckoDriver = tasks.getByPath(':tools:downloadGeckoDriver').outputs.files.asPath
        [chromeDriver, geckoDriver].each { "chmod +x ${it}".execute().waitFor() }

        def endpoint = startSystemTestEnvironment()
        logger.lifecycle("Running system tests against {}", endpoint)

        logger.lifecycle "Running Geb with -Dgeb.env=$gebEnv, override with -Pbrowser=[chrome|chromeHeadless|firefox]"
        systemProperty "geb.env", gebEnv
        systemProperty "webdriver.chrome.driver", chromeDriver
        systemProperty "webdriver.gecko.driver",  geckoDriver
        systemProperty "geb.build.reportsDir", "$reportsDir/systemTest/dumps"
        systemProperty 'geb.build.baseUrl', endpoint

        systemProperty 'expectedCodekvastVersion', codekvastDisplayVersion
        environment['CODEKVAST_VERSION'] = codekvastDisplayVersion
    }

    doLast {
        if (failures == 0) {
            doStopSystemTestEnvironment(false)
        } else {
            logger.lifecycle("Since there were failures, the system test environment is still running at {}", endpoint)
        }
    }
}

private String locateChromeBinary() {
    if (System.properties['os.name'] == 'Mac OS X') {
        def binary = new File("/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
        return binary.canExecute() ? binary : null
    } else {
        return "which google-chrome".execute().in.text.trim()
    }
}

def launchAppAndWaitForReady(String command) {
    logger.lifecycle(command)
    def process = command.execute()
    sleep 5000

    int attempt = 1
    int maxAttempts = 60
    def endpoint = getSystemTestEndpoint()
    logger.lifecycle("Waiting for {} to become ready...", endpoint)

    while (attempt <= maxAttempts) {
        assert process.isAlive()

        logger.info("Waiting for {} #{}", endpoint, attempt)

        try {
            def text = new URL(endpoint).text
            sleep 2000
            return
        } catch (e) {
            if (attempt < 15) {
                logger.debug("Got {} when getting {}, will try {} more times.", e, endpoint, maxAttempts - attempt)
            } else {
                logger.lifecycle("Got {} when getting {}, will try {} more times.", e, endpoint, maxAttempts - attempt)
            }
        }
        attempt += 1
        sleep(1000)
    }
    throw new IllegalStateException(endpoint + " did not respond within " + maxAttempts + " seconds")
}

private String getSystemTestEndpoint() {
    return file("src/test/bin/get-system-test-endpoint.sh").absolutePath.execute().in.text.trim()
}

