package se.crisp.codekvast.agent.main;

import com.google.common.base.Predicate;
import lombok.extern.slf4j.Slf4j;
import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;
import org.reflections.util.ConfigurationBuilder;
import org.springframework.stereotype.Component;
import org.xml.sax.helpers.DefaultHandler;
import se.crisp.codekvast.agent.util.SignatureUtils;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URLClassLoader;
import java.util.List;

import static java.util.Arrays.asList;

/**
 * Analyzes a code base and detects public methods. Uses the org.reflections for retrieving method signature data.
 *
 * It also contains support for mapping synthetic methods generated by runtime byte code manipulation frameworks back to the declared method
 * as it appears in the source code.
 *
 * @author Olle Hallin
 */
@Slf4j
@Component
class CodeBaseScanner {

    void getPublicMethodSignatures(CodeBase codeBase) {
        URLClassLoader appClassLoader = new URLClassLoader(codeBase.getUrls(), System.class.getClassLoader());
        List<String> packagePrefixes = codeBase.getConfig().getNormalizedPackagePrefixes();

        ConfigurationBuilder builder = ConfigurationBuilder.build(appClassLoader, new SubTypesScanner(false));
        // builder.forPackages(packagePrefixes.toArray(new String[packagePrefixes.size()]));
        // builder.forPackages("hudson");

        Predicate<String> predicate = new Predicate<String>() {
            @Override
            public boolean apply(String input) {
                return input.matches("hudson.*\\.class$");
            }
        };

        builder.filterInputsBy(predicate);
        Reflections reflections1 = new Reflections(builder);

        List<Class<Object>> rootClasses1 = asList(Object.class);
        int count1 = 0;
        for (Class<?> rootClass : rootClasses1) {
            for (Class<?> clazz : reflections1.getSubTypesOf(rootClass)) {
                count1 += 1;
                // findPublicMethods(codeBase, packagePrefixes, clazz);
            }
        }
        log.info("Found {} classes with strategy 1", count1);

        int count2 = 0;
        List<Class<?>> rootClasses2 = asList(Object.class, Enum.class, Thread.class, DefaultHandler.class, Exception.class);
//        for (String packagePrefix : packagePrefixes) {
        Reflections reflections2 = new Reflections("hudson", appClassLoader, new SubTypesScanner(false));

            for (Class<?> rootClass : rootClasses2) {
                for (Class<?> clazz : reflections2.getSubTypesOf(rootClass)) {
                    count2 += 1;
                    // findPublicMethods(codeBase, packagePrefix, clazz);
                }
            }
//        }
        log.info("Found {} classes with strategy 2", count2);
    }

    void findPublicMethods(CodeBase codeBase, String packagePrefix, Class<?> clazz) {
        log.debug("Analyzing {}", clazz);
        try {
            Method[] methods = clazz.getMethods();

            for (Method method : methods) {
                if (Modifier.isPublic(method.getModifiers())) {

                    // Some AOP frameworks (e.g., Guice) push methods from a base class down to the subclasses created in runtime.
                    // We need to map those back to the original declaring signature, or else the original,
                    // declared method will look unused.


                    String thisSignature = SignatureUtils.makeSignatureString(clazz, method);
                    String declaringSignature =
                            SignatureUtils.makeSignatureString(findDeclaringClass(method.getDeclaringClass(), method, packagePrefix),
                                                               method);

                    codeBase.addSignature(thisSignature, declaringSignature);
                }
            }

            for (Class<?> innerClass : clazz.getDeclaredClasses()) {
                findPublicMethods(codeBase, packagePrefix, innerClass);
            }
        } catch (NoClassDefFoundError e) {
            log.warn("Cannot analyze {}: {}", clazz, e.toString());
        }
    }

    private Class findDeclaringClass(Class<?> clazz, Method method, String packagePrefix) {
        if (clazz == null) {
            return null;
        }
        String pkg = clazz.getPackage().getName();
        if (!pkg.startsWith(packagePrefix)) {
            return null;
        }
        try {
            clazz.getDeclaredMethod(method.getName(), method.getParameterTypes());
            return clazz;
        } catch (NoSuchMethodException ignore) {
        }
        return findDeclaringClass(clazz.getSuperclass(), method, packagePrefix);
    }

}
